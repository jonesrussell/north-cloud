logging {
  level  = "info"
  format = "logfmt"
}

discovery.docker "north_cloud" {
  host = "unix:///var/run/docker.sock"

  filter {
    name   = "label"
    values = ["com.docker.compose.project=north-cloud"]
  }
}

// StreetCode (Laravel) - same host, Docker Compose project "streetcode" or "streetcode-laravel"
// Logs get service=streetcode, project=north-cloud so pipeline dashboard panels match
discovery.docker "streetcode" {
  host = "unix:///var/run/docker.sock"

  filter {
    name   = "label"
    values = ["com.docker.compose.project=streetcode"]
  }
}

discovery.docker "streetcode_laravel" {
  host = "unix:///var/run/docker.sock"

  filter {
    name   = "label"
    values = ["com.docker.compose.project=streetcode-laravel"]
  }
}

discovery.relabel "north_cloud" {
  targets = discovery.docker.north_cloud.targets

  // Drop Grafana, Loki, and Alloy containers - check container name first
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/north-cloud-(grafana|loki|alloy)-[0-9]+"
    action        = "drop"
  }

  // Also drop by service label (fallback)
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    regex         = "^(grafana|loki|alloy)$"
    action        = "drop"
  }

  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/north-cloud-(.+?)(?:-\\d+)?"
    target_label  = "service"
    replacement   = "$1"
  }

  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
  }

  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    target_label  = "project"
  }

  rule {
    source_labels = ["project"]
    regex         = "^$"
    replacement   = "north-cloud"
    target_label  = "project"
  }

  rule {
    source_labels = ["__meta_docker_container_id"]
    regex         = "^(.{12}).*"
    replacement   = "$1"
    target_label  = "container_id"
  }

  rule {
    target_label = "job"
    replacement  = "docker"
  }
}

discovery.relabel "streetcode" {
  targets = discovery.docker.streetcode.targets

  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
    replacement   = "streetcode"
  }
  rule {
    target_label = "project"
    replacement  = "north-cloud"
  }
  rule {
    source_labels = ["__meta_docker_container_id"]
    regex         = "^(.{12}).*"
    replacement   = "$1"
    target_label  = "container_id"
  }
  rule {
    target_label = "job"
    replacement  = "docker"
  }
}

discovery.relabel "streetcode_laravel" {
  targets = discovery.docker.streetcode_laravel.targets

  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
    replacement   = "streetcode"
  }
  rule {
    target_label = "project"
    replacement  = "north-cloud"
  }
  rule {
    source_labels = ["__meta_docker_container_id"]
    regex         = "^(.{12}).*"
    replacement   = "$1"
    target_label  = "container_id"
  }
  rule {
    target_label = "job"
    replacement  = "docker"
  }
}

loki.source.docker "north_cloud" {
  host          = "unix:///var/run/docker.sock"
  targets       = discovery.relabel.north_cloud.output
  forward_to    = [loki.process.north_cloud.receiver]
  relabel_rules = discovery.relabel.north_cloud.rules
}

loki.source.docker "streetcode" {
  host          = "unix:///var/run/docker.sock"
  targets       = discovery.relabel.streetcode.output
  forward_to    = [loki.process.north_cloud.receiver]
  relabel_rules = discovery.relabel.streetcode.rules
}

loki.source.docker "streetcode_laravel" {
  host          = "unix:///var/run/docker.sock"
  targets       = discovery.relabel.streetcode_laravel.output
  forward_to    = [loki.process.north_cloud.receiver]
  relabel_rules = discovery.relabel.streetcode_laravel.rules
}

// ── Deployer sites (host Laravel apps, mounted into container) ──────────────
// Logs are tailed from /mnt/sites/{site}/current/storage/logs/*.log.
// Each site directory is bind-mounted in docker-compose.prod.yml so the
// current/ symlink resolves correctly across deploys.
// local.file_match resolves globs; loki.source.file tails resolved paths.

local.file_match "streetcode_logs" {
  path_targets = [{
    __path__ = "/mnt/sites/streetcode-laravel/current/storage/logs/*.log",
    project  = "north-cloud",
    service  = "streetcode",
    job      = "file",
  }]
  sync_period = "10s"
}

loki.source.file "streetcode_logs" {
  targets       = local.file_match.streetcode_logs.targets
  forward_to    = [loki.process.laravel.receiver]
  tail_from_end = true
}

local.file_match "orewire_logs" {
  path_targets = [{
    __path__ = "/mnt/sites/orewire-laravel/current/storage/logs/*.log",
    project  = "north-cloud",
    service  = "orewire",
    job      = "file",
  }]
  sync_period = "10s"
}

loki.source.file "orewire_logs" {
  targets       = local.file_match.orewire_logs.targets
  forward_to    = [loki.process.laravel.receiver]
  tail_from_end = true
}

local.file_match "coforge_logs" {
  path_targets = [{
    __path__ = "/mnt/sites/coforge/current/storage/logs/*.log",
    project  = "north-cloud",
    service  = "coforge",
    job      = "file",
  }]
  sync_period = "10s"
}

loki.source.file "coforge_logs" {
  targets       = local.file_match.coforge_logs.targets
  forward_to    = [loki.process.laravel.receiver]
  tail_from_end = true
}

local.file_match "movies_of_war_logs" {
  path_targets = [{
    __path__ = "/mnt/sites/movies-of-war.com/current/storage/logs/*.log",
    project  = "north-cloud",
    service  = "movies-of-war",
    job      = "file",
  }]
  sync_period = "10s"
}

loki.source.file "movies_of_war_logs" {
  targets       = local.file_match.movies_of_war_logs.targets
  forward_to    = [loki.process.laravel.receiver]
  tail_from_end = true
}

// ── Laravel log processing ─────────────────────────────────────────────────
// Format: [2026-02-14 02:30:00] production.INFO: Message {"context":"data"}

loki.process "laravel" {
  stage.regex {
    expression = "\\[(?P<timestamp>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] \\w+\\.(?P<level>\\w+):"
  }

  stage.timestamp {
    source            = "timestamp"
    format            = "2006-01-02 15:04:05"
    action_on_failure = "fudge"
  }

  stage.template {
    source   = "level"
    template = "{{ ToLower .Value }}"
  }

  stage.labels {
    values = { level = "" }
  }

  forward_to = [loki.write.north_cloud.receiver]
}

loki.process "north_cloud" {
  // Parse JSON logs directly - loki.source.docker already unwraps Docker format
  stage.json {
    expressions = {
      level       = "level",
      logger      = "logger",
      caller      = "caller",
      msg         = "msg",
      ts          = "ts",
      t           = "t",
      log_service = "service",
      stream      = "stream",
      method      = "method",
      path        = "path",
      error       = "error",
      err         = "err",
      duration    = "duration",
      status_code = "status_code",
    }
  }

  // Drop high-frequency health check logs to reduce Loki ingestion noise
  // Structured JSON logs (Go services): match extracted "path" field
  stage.drop {
    source     = "path"
    expression = "^/health$"
  }

  // Plain-text health check logs (Uvicorn/FastAPI ML sidecars)
  // Matches: INFO:     127.0.0.1:PORT - "GET /health HTTP/1.1" 200 OK
  stage.drop {
    expression = "GET /health HTTP"
  }

  // Fallback: Parse logfmt logs if JSON parsing didn't happen
  stage.match {
    selector = "{log=~\"level=\", level=\"\"}"
    stage.logfmt {
      source = "log"
      mapping = {
        level       = "level",
        msg         = "msg",
        ts          = "ts",
        t           = "t",
        logger      = "logger",
        caller      = "caller",
        method      = "method",
        error       = "error",
        err         = "err",
        duration    = "duration",
        status_code = "status_code",
      }
    }
  }

  // Fallback: Extract level via regex if not already extracted
  stage.match {
    selector = "{level=\"\"}"
    stage.regex {
      source     = "log"
      expression = "(?i)(?:\"level\"\\s*:\\s*\"|level\\s*=\\s*)(?P<level>debug|info|warn|warning|error|fatal|panic)"
    }
  }

  // Promote extracted level field to label (runs after all extraction attempts)
  stage.labels {
    values = { level = "" }
  }

  // Normalize warning to warn (after label is created)
  stage.match {
    selector = "{level=\"warning\"}"
    stage.static_labels {
      values = { level = "warn" }
    }
  }

  stage.timestamp {
    source = "ts"
    format = "RFC3339Nano"
    fallback_formats = [
      "RFC3339",
      "2006-01-02T15:04:05.000Z07:00",
      "2006-01-02T15:04:05Z07:00",
      "2006-01-02T15:04:05.000000000Z07:00",
    ]
    action_on_failure = "fudge"
  }

  stage.match {
    selector = "{ts=\"\"}"
    stage.timestamp {
      source = "t"
      format = "RFC3339Nano"
      fallback_formats = [
        "RFC3339",
        "2006-01-02T15:04:05.000Z07:00",
        "2006-01-02T15:04:05Z07:00",
        "2006-01-02T15:04:05.000000000Z07:00",
      ]
      action_on_failure = "fudge"
    }
  }

  stage.match {
    selector = "{ts=\"\"}"
    stage.timestamp {
      source = "time"
      format = "RFC3339Nano"
      fallback_formats = [
        "RFC3339",
        "2006-01-02T15:04:05.000Z07:00",
        "2006-01-02T15:04:05Z07:00",
        "2006-01-02T15:04:05.000000000Z07:00",
      ]
      action_on_failure = "fudge"
    }
  }

  stage.labels { values = { stream = "" } }

  // Keep the full JSON log line - don't use stage.output to preserve all details
  // The log line will contain the complete JSON with all fields

  forward_to = [loki.write.north_cloud.receiver]
}

loki.write "north_cloud" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
    remote_timeout = "10s"
    batch_wait     = "1s"
    batch_size     = "100KiB"
    min_backoff_period  = "500ms"
    max_backoff_period  = "5m"
    max_backoff_retries = 10
  }
}
