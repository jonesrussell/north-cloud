// Grafana Alloy Configuration
logging {
  level  = "info"
  format = "logfmt"
}

discovery.docker "north_cloud" {
  host = "unix:///var/run/docker.sock"
  refresh_interval = "5s"

  filter {
    name   = "label"
    values = ["com.docker.compose.project=north-cloud"]
  }
}

discovery.relabel "north_cloud" {
  targets = discovery.docker.north_cloud.targets

  // Extract service name from container name
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/north-cloud-(.+?)(?:-\\d+)?"
    target_label  = "service"
    replacement   = "$1"
  }

  // Prefer Compose service label
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
  }

  // Project name
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    target_label  = "project"
  }

  // Fallback project
  rule {
    source_labels = ["project"]
    regex         = "^$"
    replacement   = "north-cloud"
    target_label  = "project"
  }

  // Short container ID
  rule {
    source_labels = ["__meta_docker_container_id"]
    regex         = "^(.{12}).*"
    replacement   = "$1"
    target_label  = "container_id"
  }

  rule {
    target_label = "job"
    replacement  = "docker"
  }
}

loki.source.docker "north_cloud" {
  host        = "unix:///var/run/docker.sock"
  targets     = discovery.relabel.north_cloud.output
  forward_to  = [loki.process.north_cloud.receiver]
  relabel_rules = discovery.relabel.north_cloud.rules
}

loki.process "north_cloud" {
  // Parse Docker JSON wrapper
  stage.json {
    expressions = {
      log    = "log"
      stream = "stream"
      time   = "time"
    }
  }

  // JSON-first parsing
  stage.match {
    selector = "{log=~\"^\\\\s*\\\\{.*\"}"

    stage.json {
      source = "log"
      expressions = {
        level       = "level"
        logger      = "logger"
        caller      = "caller"
        msg         = "msg"
        ts          = "ts"
        t           = "t"
        log_service = "service"
        method      = "method"
        error       = "error"
        err         = "err"
        duration    = "duration"
        status_code = "status_code"
      }
    }
  }

  // Logfmt fallback
  stage.match {
    selector = "{level=\"\"}"

    stage.logfmt {
      source = "log"
      mapping = {
        level       = "level"
        msg         = "msg"
        ts          = "ts"
        t           = "t"
        logger      = "logger"
        caller      = "caller"
        method      = "method"
        error       = "error"
        err         = "err"
        duration    = "duration"
        status_code = "status_code"
      }
    }
  }

  // Regex fallback for plain text logs
  stage.match {
    selector = "{level=\"\"}"

    stage.regex {
      source     = "log"
      expression = "(?i)(?:level=)?(debug|info|warn|warning|error|fatal|panic)"
    }
  }

  // Normalize "warning"
  stage.match {
    selector = "{level=\"warning\"}"
    stage.static_labels { values = { level = "warn" } }
  }

  // Default level
  stage.match {
    selector = "{level=\"\"}"
    stage.static_labels { values = { level = "info" } }
  }

  // Timestamp parsing (ts → t → time)
  stage.timestamp {
    source = "ts"
    format = "RFC3339Nano"
    fallback_formats = [
      "RFC3339",
      "2006-01-02T15:04:05.000Z07:00",
      "2006-01-02T15:04:05Z07:00",
      "2006-01-02T15:04:05.000000000Z07:00",
    ]
    action_on_failure = "fudge"
  }

  stage.match {
    selector = "{ts=\"\"}"
    stage.timestamp {
      source = "t"
      format = "RFC3339Nano"
      fallback_formats = [
        "RFC3339",
        "2006-01-02T15:04:05.000Z07:00",
        "2006-01-02T15:04:05Z07:00",
        "2006-01-02T15:04:05.000000000Z07:00",
      ]
      action_on_failure = "fudge"
    }
  }

  stage.match {
    selector = "{ts=\"\"}"
    stage.timestamp {
      source = "time"
      format = "RFC3339Nano"
      fallback_formats = [
        "RFC3339",
        "2006-01-02T15:04:05.000Z07:00",
        "2006-01-02T15:04:05Z07:00",
        "2006-01-02T15:04:05.000000000Z07:00",
      ]
      action_on_failure = "fudge"
    }
  }

  // Add stream label
  stage.labels { values = { stream = "" } }

  // Prefer msg → fallback to log
  stage.output { source = "msg" }
  stage.match {
    selector = "{msg=\"\"}"
    stage.output { source = "log" }
  }

  forward_to = [loki.write.north_cloud.receiver]
}

loki.write "north_cloud" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
    remote_timeout = "10s"
    batch_wait     = "1s"
    batch_size     = "100KiB"
    min_backoff_period  = "500ms"
    max_backoff_period  = "5m"
    max_backoff_retries = 10
  }
}
