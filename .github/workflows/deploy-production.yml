name: Deploy to Production

on:
  push:
    branches:
      - main

env:
  REGISTRY: docker.io
  IMAGE_PREFIX: northcloud

jobs:
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    outputs:
      commit-sha: ${{ steps.vars.outputs.commit_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract commit SHA
        id: vars
        run: |
          echo "commit_sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build and save images
        run: |
          COMMIT_SHA="${{ steps.vars.outputs.commit_sha }}"
          mkdir -p images
          
          # Services to build (matching docker-compose.prod.yml)
          SERVICES=(
            "auth"
            "crawler"
            "source-manager"
            "classifier"
            "index-manager"
            "publisher"
            "search-service"
            "search-frontend"
            "dashboard"
          )
          
          # Build each service
          for service in "${SERVICES[@]}"; do
            echo "Building $service..."
            docker compose -f docker-compose.base.yml -f docker-compose.prod.yml build "$service"
            
            # Tag with commit SHA
            docker tag "${IMAGE_PREFIX}/${service}:latest" "${IMAGE_PREFIX}/${service}:${COMMIT_SHA}"
            
            # Save image to tar archive
            echo "Saving ${service} image..."
            docker save -o "images/${service}.tar" "${IMAGE_PREFIX}/${service}:${COMMIT_SHA}"
            
            # Also save latest tag for rollback reference
            docker save -o "images/${service}-latest.tar" "${IMAGE_PREFIX}/${service}:latest"
          done
          
          # List created images
          ls -lh images/

      - name: Upload images artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: images/*.tar
          retention-days: 1

  deploy:
    name: Deploy to Production
    needs: build-images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract commit SHA
        id: vars
        run: |
          echo "commit_sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Download images artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-images
          path: images/

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Set deployment variables
        id: deploy-vars
        env:
            SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
        run: |
            echo "ssh_port=${SSH_PORT}" >> $GITHUB_OUTPUT
            echo "deploy_user=${{ secrets.DEPLOY_USER }}" >> $GITHUB_OUTPUT
            echo "deploy_host=${{ secrets.DEPLOY_HOST }}" >> $GITHUB_OUTPUT
            echo "deploy_path=${{ secrets.DEPLOY_PATH }}" >> $GITHUB_OUTPUT

      - name: Add server to known hosts
        env:
          SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
        run: |
          ssh-keyscan -p ${SSH_PORT} ${DEPLOY_HOST} >> ~/.ssh/known_hosts

      - name: Create deployment directory structure
        env:
          SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh -p ${SSH_PORT} ${DEPLOY_USER}@${DEPLOY_HOST} bash -c "
            set -e
            mkdir -p \"${DEPLOY_PATH}\"/{crawler,source-manager,classifier,publisher,index-manager,search,auth,infrastructure/nginx,infrastructure/elasticsearch}
            mkdir -p \"${DEPLOY_PATH}\"/crawler/migrations
            mkdir -p \"${DEPLOY_PATH}\"/source-manager/migrations
            mkdir -p \"${DEPLOY_PATH}\"/classifier/migrations
            mkdir -p \"${DEPLOY_PATH}\"/publisher/internal/database/migrations
            mkdir -p \"${DEPLOY_PATH}\"/index-manager/migrations
            mkdir -p \"${DEPLOY_PATH}\"/images
            echo \"Directory structure created\"
          "

      - name: Transfer Docker images
        run: |
          COMMIT_SHA="${{ steps.vars.outputs.commit_sha }}"
          scp -P ${DEPLOY_SSH_PORT:-22} images/*.tar ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/images/
          
          ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << EOF
            set -e
            cd "${{ secrets.DEPLOY_PATH }}/images"
            
            # Load all images
            echo "Loading Docker images..."
            for tar_file in *.tar; do
              echo "Loading \$tar_file..."
              docker load -i "\$tar_file"
            done
            
            # Clean up tar files
            rm -f *.tar
            
            echo "Images loaded successfully"
          EOF

      - name: Transfer docker-compose files
        run: |
          scp -P ${{ steps.deploy-vars.outputs.ssh_port }} docker-compose.base.yml ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/
          scp -P ${{ steps.deploy-vars.outputs.ssh_port }} docker-compose.prod.yml ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/

      - name: Transfer config files
        run: |
          # Transfer service config files (if they exist)
          for service in crawler classifier publisher index-manager search; do
            if [ -f "$service/config.yml" ]; then
              echo "Transferring $service/config.yml"
              ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "mkdir -p ${{ secrets.DEPLOY_PATH }}/$service"
              scp -P ${DEPLOY_SSH_PORT:-22} "$service/config.yml" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/$service/
            fi
          done
          
          # Transfer auth config if exists
          if [ -f "auth/config.yml" ]; then
            ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "mkdir -p ${{ secrets.DEPLOY_PATH }}/auth"
            scp -P ${DEPLOY_SSH_PORT:-22} "auth/config.yml" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/auth/
          fi
          
          # Transfer infrastructure configs
          if [ -f "infrastructure/nginx/nginx.conf" ]; then
            scp -P ${DEPLOY_SSH_PORT:-22} infrastructure/nginx/nginx.conf ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/infrastructure/nginx/
          fi
          
          if [ -f "infrastructure/elasticsearch/elasticsearch.yml" ]; then
            scp -P ${DEPLOY_SSH_PORT:-22} infrastructure/elasticsearch/elasticsearch.yml ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/infrastructure/elasticsearch/
          fi

      - name: Transfer migration files
        run: |
          # Transfer migrations for each service
          for service in crawler source-manager classifier; do
            if [ -d "$service/migrations" ] && [ "$(ls -A $service/migrations 2>/dev/null)" ]; then
              echo "Transferring $service migrations..."
              scp -r -P ${DEPLOY_SSH_PORT:-22} "$service/migrations"/* ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/$service/migrations/
            fi
          done
          
          # Publisher migrations are in a subdirectory
          if [ -d "publisher/internal/database/migrations" ] && [ "$(ls -A publisher/internal/database/migrations 2>/dev/null)" ]; then
            echo "Transferring publisher migrations..."
            ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "mkdir -p ${{ secrets.DEPLOY_PATH }}/publisher/internal/database/migrations"
            scp -r -P ${DEPLOY_SSH_PORT:-22} publisher/internal/database/migrations/* ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/publisher/internal/database/migrations/
          fi
          
          # Index manager migrations
          if [ -d "index-manager/migrations" ] && [ "$(ls -A index-manager/migrations 2>/dev/null)" ]; then
            echo "Transferring index-manager migrations..."
            scp -r -P ${DEPLOY_SSH_PORT:-22} index-manager/migrations/* ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}/index-manager/migrations/
          fi

      - name: Run database migrations
        run: |
          ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'MIGRATE_EOF'
            set -e
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            COMMIT_SHA="${{ steps.vars.outputs.commit_sha }}"
            
            cd "$DEPLOY_PATH"
            
            # Ensure infrastructure services are running for migrations
            echo "Starting infrastructure services..."
            docker compose -f docker-compose.base.yml -f docker-compose.prod.yml up -d postgres-crawler postgres-source-manager postgres-classifier postgres-publisher postgres-index-manager
            
            # Wait for databases to be ready
            echo "Waiting for databases to be ready..."
            sleep 10
            
            # Function to run migrations for a service
            run_migration() {
              local service=$1
              local db_host=$2
              local db_port=$3
              local db_user=$4
              local db_password=$5
              local db_name=$6
              local migrations_path=$7
              
              echo "Running migrations for $service..."
              
              # Check if migrations directory exists and has files
              if [ ! -d "$migrations_path" ] || [ -z "$(ls -A $migrations_path 2>/dev/null)" ]; then
                echo "No migrations found for $service, skipping..."
                return 0
              fi
              
              # Get current version (if any)
              CURRENT_VERSION=$(docker run --rm --network north-cloud_north-cloud-network \
                migrate/migrate:latest \
                -path /migrations \
                -database "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable" \
                version 2>/dev/null | grep -o '[0-9]*' | head -1 || echo "0")
              
              echo "Current migration version for $service: $CURRENT_VERSION"
              
              # Run migrations
              docker run --rm --network north-cloud_north-cloud-network \
                -v "$DEPLOY_PATH/$migrations_path:/migrations" \
                migrate/migrate:latest \
                -path /migrations \
                -database "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable" \
                up || {
                  echo "ERROR: Migration failed for $service"
                  return 1
                }
              
              # Get new version
              NEW_VERSION=$(docker run --rm --network north-cloud_north-cloud-network \
                migrate/migrate:latest \
                -path /migrations \
                -database "postgres://${db_user}:${db_password}@${db_host}:${db_port}/${db_name}?sslmode=disable" \
                version 2>/dev/null | grep -o '[0-9]*' | head -1 || echo "0")
              
              echo "New migration version for $service: $NEW_VERSION"
              echo "Migration completed successfully for $service"
            }
            
            # Run migrations in order (infrastructure first, then processing services)
            # Note: These use environment variables from .env file on the server
            
            # Source Manager (infrastructure)
            if [ -n "$POSTGRES_SOURCE_MANAGER_USER" ] && [ -n "$POSTGRES_SOURCE_MANAGER_PASSWORD" ]; then
              run_migration "source-manager" \
                "postgres-source-manager" "5432" \
                "$POSTGRES_SOURCE_MANAGER_USER" \
                "$POSTGRES_SOURCE_MANAGER_PASSWORD" \
                "${POSTGRES_SOURCE_MANAGER_DB:-gosources}" \
                "source-manager/migrations"
            else
              echo "WARNING: POSTGRES_SOURCE_MANAGER credentials not found, skipping source-manager migrations"
            fi
            
            # Crawler (infrastructure)
            if [ -n "$POSTGRES_CRAWLER_USER" ] && [ -n "$POSTGRES_CRAWLER_PASSWORD" ]; then
              run_migration "crawler" \
                "postgres-crawler" "5432" \
                "$POSTGRES_CRAWLER_USER" \
                "$POSTGRES_CRAWLER_PASSWORD" \
                "${POSTGRES_CRAWLER_DB:-crawler}" \
                "crawler/migrations"
            else
              echo "WARNING: POSTGRES_CRAWLER credentials not found, skipping crawler migrations"
            fi
            
            # Classifier (processing)
            if [ -n "$POSTGRES_CLASSIFIER_USER" ] && [ -n "$POSTGRES_CLASSIFIER_PASSWORD" ]; then
              run_migration "classifier" \
                "postgres-classifier" "5432" \
                "$POSTGRES_CLASSIFIER_USER" \
                "$POSTGRES_CLASSIFIER_PASSWORD" \
                "${POSTGRES_CLASSIFIER_DB:-classifier}" \
                "classifier/migrations"
            else
              echo "WARNING: POSTGRES_CLASSIFIER credentials not found, skipping classifier migrations"
            fi
            
            # Publisher (processing)
            if [ -n "$POSTGRES_PUBLISHER_USER" ] && [ -n "$POSTGRES_PUBLISHER_PASSWORD" ]; then
              run_migration "publisher" \
                "postgres-publisher" "5432" \
                "$POSTGRES_PUBLISHER_USER" \
                "$POSTGRES_PUBLISHER_PASSWORD" \
                "${POSTGRES_PUBLISHER_DB:-publisher}" \
                "publisher/internal/database/migrations"
            else
              echo "WARNING: POSTGRES_PUBLISHER credentials not found, skipping publisher migrations"
            fi
            
            # Index Manager (supporting)
            if [ -n "$POSTGRES_INDEX_MANAGER_USER" ] && [ -n "$POSTGRES_INDEX_MANAGER_PASSWORD" ]; then
              run_migration "index-manager" \
                "postgres-index-manager" "5432" \
                "$POSTGRES_INDEX_MANAGER_USER" \
                "$POSTGRES_INDEX_MANAGER_PASSWORD" \
                "${POSTGRES_INDEX_MANAGER_DB:-index_manager}" \
                "index-manager/migrations"
            else
              echo "WARNING: POSTGRES_INDEX_MANAGER credentials not found, skipping index-manager migrations"
            fi
            
            echo "All migrations completed successfully"
          MIGRATE_EOF

      - name: Deploy services
        id: deploy
        run: |
          ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'DEPLOY_EOF'
            set -e
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            COMMIT_SHA="${{ steps.vars.outputs.commit_sha }}"
            
            cd "$DEPLOY_PATH"
            
            echo "Deploying services with commit $COMMIT_SHA..."
            
            # Pull environment variables from .env file
            if [ -f .env ]; then
              set -a
              source .env
              set +a
            else
              echo "WARNING: .env file not found. Services may not start correctly."
            fi
            
            # Deploy all services
            docker compose -f docker-compose.base.yml -f docker-compose.prod.yml up -d
            
            echo "Services deployed. Checking status..."
            docker compose -f docker-compose.base.yml -f docker-compose.prod.yml ps
            
            echo "deployment_success=true" >> $GITHUB_OUTPUT
          DEPLOY_EOF

      - name: Health check services
        run: |
          ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'HEALTH_EOF'
            set -e
            
            echo "Waiting for services to start (30 seconds)..."
            sleep 30
            
            # Function to check health endpoint
            check_health() {
              local service_name=$1
              local health_url=$2
              local max_attempts=${3:-5}
              local attempt=1
              
              echo "Checking health for $service_name at $health_url..."
              
              while [ $attempt -le $max_attempts ]; do
                if curl -f -s "$health_url" > /dev/null 2>&1; then
                  echo "✓ $service_name is healthy"
                  return 0
                fi
                
                echo "Attempt $attempt/$max_attempts: $service_name not ready yet, waiting 30 seconds..."
                sleep 30
                attempt=$((attempt + 1))
              done
              
              echo "✗ $service_name health check failed after $max_attempts attempts"
              return 1
            }
            
            # Check critical services
            # Note: Health check URLs depend on how services are exposed (nginx reverse proxy or direct)
            # Adjust these based on your actual setup
            
            FAILED_CHECKS=0
            
            # Check via nginx (if services are behind nginx)
            # If nginx is not set up yet or services are exposed directly, adjust URLs
            
            # Auth service
            if ! check_health "auth" "http://localhost:8040/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            # Source Manager
            if ! check_health "source-manager" "http://localhost:8050/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            # Crawler
            if ! check_health "crawler" "http://localhost:8060/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            # Classifier
            if ! check_health "classifier" "http://localhost:8070/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            # Publisher
            if ! check_health "publisher" "http://localhost:8070/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            # Index Manager
            if ! check_health "index-manager" "http://localhost:8090/api/v1/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            # Search Service
            if ! check_health "search-service" "http://localhost:8090/health" 5; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
            fi
            
            if [ $FAILED_CHECKS -gt 0 ]; then
              echo "ERROR: $FAILED_CHECKS service(s) failed health checks"
              exit 1
            fi
            
            echo "All health checks passed successfully"
          HEALTH_EOF

      - name: Rollback on failure
        if: failure()
        run: |
          ssh -p ${DEPLOY_SSH_PORT:-22} ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'ROLLBACK_EOF'
            set -e
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            cd "$DEPLOY_PATH"
            
            echo "Deployment failed. Rolling back..."
            
            # Stop all services
            docker compose -f docker-compose.base.yml -f docker-compose.prod.yml down || true
            
            echo "Rollback completed. Previous images are still available."
            echo "To restore previous version, run:"
            echo "  cd $DEPLOY_PATH"
            echo "  docker compose -f docker-compose.base.yml -f docker-compose.prod.yml up -d"
          ROLLBACK_EOF

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA**: ${{ steps.vars.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to**: ${{ secrets.DEPLOY_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "✓ Deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "✗ Deployment failed. Check logs for details." >> $GITHUB_STEP_SUMMARY
          fi
