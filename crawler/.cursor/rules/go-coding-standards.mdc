# Go Coding Standards

## Code Style
- Follow Go standard formatting (use `go fmt` or `gofmt`)
- Use meaningful variable and function names
- Keep functions focused and single-purpose
- Use proper Go idioms and patterns

## Error Handling
- Always check and handle errors explicitly
- Use `if err != nil` pattern consistently
- Return errors up the call stack when appropriate
- Use `fmt.Errorf` with context for error wrapping

## Package Organization
- Keep packages focused and cohesive
- Use `internal/` for private packages
- Follow Go module conventions
- Use meaningful package names

## Testing
- Write tests for all public functions
- Use `testify` for assertions and mocking
- Follow Go testing conventions
- Use table-driven tests when appropriate
- Test utilities in `internal/*/testing/` packages are acceptable (e.g., `internal/storage/testing/logger.go`)
- Test utilities may have different dependencies than production code

## Logging
- Use structured logging with Zap
- Include relevant context in log messages
- Use appropriate log levels (debug, info, warn, error)
- Avoid logging sensitive information

## Configuration
- Use Viper for configuration management
- Support environment variables and config files
- Validate configuration on startup
- Use sensible defaults

## Dependencies
- Use Go modules for dependency management
- Keep dependencies up to date
- Avoid unnecessary external dependencies
- Use `go mod tidy` to clean up dependencies

## Code Maintenance
- Regularly remove unused code (functions, types, variables)
- Use static analysis tools to identify dead code
- Remove helper functions that are only used by unused code
- Update comments when removing referenced code

## Refactoring and Code Quality
- Extract helper functions to eliminate code duplication
- Keep functions under 100 lines when possible
- Break down complex functions into smaller, focused functions
- Use helper functions to reduce duplication in type conversions
- Refactor when linters detect duplication or excessive function length

## Context Usage
- Use `CommandDeps` struct for explicit dependency passing (see command-architecture.mdc)
- DO NOT use `context.Value()` for dependency injection - use `common.NewCommandDeps()` factory
- Always check for errors when creating dependencies
- Use `cmd.Context()` for cancellation and timeouts only

## Dependency Injection
- Use `common.NewCommandDeps()` factory to get logger and config
- Use `common.CreateStorageClient()` for storage client creation
- Construct dependencies directly in command RunE functions
- DO NOT use FX modules - FX has been completely removed from the codebase
- Keep dependency construction explicit and clear

## Command Implementation
- All commands MUST use `Command()` function pattern for registration
- Commands MUST use `common.NewCommandDeps()` to get dependencies
- Commands MUST use `common.CreateStorageClient()` for storage
- Use constants from `internal/constants/constants.go` instead of magic strings/numbers
- Use `atomic.Int32` directly for atomic operations (not `*int32`)
- Implement graceful shutdown for long-running commands
- See command-architecture.mdc for detailed patterns

## Parameter Naming
- Avoid shadowing imported package names with parameters
- Use shortened names when needed (e.g., `stor` instead of `storage`, `hostname` instead of `domain`)
- Follow established naming conventions consistently
- When importing `internal/domain`, avoid using variable name `domain` (use `hostname` for URL hostnames)
- When importing `internal/job`, avoid using variable name `job` (use `jobObj` or `j` for job parameters)

## Interface Organization
- **Interfaces SHOULD be defined in the same file as their implementation**
- Prefer consolidating interfaces into implementation files when possible
- Use compile-time interface checks: `var _ InterfaceName = (*Implementation)(nil)`
- Pattern:
  ```go
  // In implementation file (e.g., internal/sources/sources.go)
  package sources
  
  // Interface defines the contract for source management
  type Interface interface {
      // ... methods ...
  }
  
  // Sources implements Interface
  type Sources struct {
      // ... fields ...
  }
  
  // Compile-time check
  var _ Interface = (*Sources)(nil)
  ```
- Exceptions:
  - `internal/storage/types/interface.go` - kept separate to avoid circular dependencies
  - `internal/job/interface.go` - Service interface defined separately from BaseService implementation to avoid name conflicts

## Constants Organization
- **All shared constants MUST be defined in `internal/constants/constants.go`**
- Constants are organized by domain: HTTP/Server, Crawler, Storage, Logger, General
- Use constants from `internal/constants` package - DO NOT create duplicate constant files
- DO NOT use `cmd/common/constants.go` (deprecated and removed)
- Pattern:
  ```go
  import "github.com/jonesrussell/gocrawl/internal/constants"
  
  // Use constants
  timeout := constants.DefaultRateLimit
  bufferSize := constants.DefaultBufferSize
  shutdownTimeout := constants.DefaultShutdownTimeout
  ```

## Domain Models
- **Use `internal/domain` package for all domain models** (not `internal/models`)
- Domain types: `domain.Article`, `domain.Page`, `domain.Content`, `domain.Job`
- Import pattern: `import "github.com/jonesrussell/gocrawl/internal/domain"`
- Type constants are prefixed with `Type` (e.g., `domain.TypeArticle`, `domain.TypePage`) to avoid conflicts with struct types

## Package Structure
- **Avoid catch-all packages** - each package should have a single, clear responsibility
- `internal/common/` now only contains `transport/` subpackage (TLS utilities and transport constant re-exports)
- Domain-specific utilities have been moved to their respective packages:
  - Job interface: `internal/job/interface.go` (Service interface)
  - Job implementation: `internal/job/service.go` (BaseService struct)
  - Source utilities: `internal/sources/utils.go` (ConvertSourceConfig, ExtractDomain)
- All constants: `internal/constants/constants.go` (no duplicates in common package)
- Do not create circular dependencies - use type packages when needed (`internal/storage/types/`)
- When importing `internal/job`, use `job.Service` interface (not `common.JobService`)

description:
globs:
alwaysApply: true
---
